<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>EVP Audio Analyzer - Quantum Strangeness</title>

  <!-- Sci-fi font -->
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg-1: #020204;
      --bg-2: #071018;
      --neon: #00f0ff;
      --neon-2: #7efc6f;
      --muted: #9aa6ad;
      --panel: rgba(255,255,255,0.03);
    }

    /* base */
    *{box-sizing:border-box; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;}
    html,body{height:100%; margin:0; font-family:Inter, Arial, sans-serif; color:#e8f8fb; background: radial-gradient(1200px 600px at 10% 10%, rgba(0,240,255,0.04), transparent 8%), linear-gradient(180deg, var(--bg-1) 0%, var(--bg-2) 100%); overflow-y:auto;}
    .container{max-width:1200px; margin:24px auto; padding:22px; position:relative; z-index:3;}

    /* subtle animated particles/noise */
    .bg-noise {
      position:fixed; inset:0; pointer-events:none; z-index:0;
      background-image: radial-gradient(circle at 10% 20%, rgba(0,255,255,0.02), transparent 8%),
                        radial-gradient(circle at 85% 80%, rgba(126,252,111,0.02), transparent 8%);
      mix-blend-mode:screen; opacity:0.9;
      animation: shiftBG 18s linear infinite alternate;
    }
    @keyframes shiftBG { from{transform:translate3d(0,0,0)} to{transform:translate3d(-4%,2%,0)} }

    /* scanlines / vignette */
    body::before{
      content:""; position:fixed; inset:0; pointer-events:none; z-index:1;
      background-image: linear-gradient(transparent, rgba(0,0,0,0.18));
    }
    .scanlines{
      position:fixed; inset:0; pointer-events:none; z-index:2;
      background-image: linear-gradient(rgba(0,0,0,0), rgba(0,0,0,0.06));
      background-size: 100% 3px; opacity:0.55;
      mix-blend-mode:overlay;
    }

    /* header */
    .header{ text-align:center; margin-bottom:20px; }
    .logo {
      display:inline-flex; align-items:center; gap:12px;
      font-family: 'Orbitron', sans-serif; letter-spacing:0.14em;
    }
    .logo-mark{
      width:56px; height:56px; border-radius:10px;
      background: linear-gradient(135deg, rgba(0,240,255,0.18), rgba(126,252,111,0.08));
      box-shadow: 0 0 18px rgba(0,240,255,0.07), inset 0 -6px 18px rgba(0,0,0,0.6);
      display:flex; align-items:center; justify-content:center; color:var(--neon);
      font-weight:700; font-size:18px; border:1px solid rgba(0,240,255,0.12);
      transform-origin:center;
      animation: pulseLogo 2.4s ease-in-out infinite;
    }
    @keyframes pulseLogo { 0%{transform:scale(1)} 50%{transform:scale(1.06)} 100%{transform:scale(1)} }

    h1{ margin:0; font-size:28px; color:var(--neon); text-shadow: 0 6px 18px rgba(0,240,255,0.06); }
    .subtitle{ color:var(--muted); margin-top:6px; font-size:14px; }

    .top-actions{ margin-top:10px; display:flex; gap:12px; justify-content:center; align-items:center; }

    .top-actions a{ color:var(--neon); text-decoration:none; font-weight:600; background: rgba(0,240,255,0.02); padding:8px 12px; border-radius:8px; border:1px solid rgba(0,240,255,0.04); }

    /* upload zone */
    .upload-zone {
      position:relative; z-index:3;
      border-radius:12px; padding:48px 26px; text-align:center;
      background: linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.006));
      border: 1px solid rgba(0,240,255,0.06);
      box-shadow: 0 10px 40px rgba(2,6,10,0.8), inset 0 1px 0 rgba(255,255,255,0.02);
      transition: transform .18s ease, box-shadow .18s ease, border-color .18s ease;
      cursor:pointer;
      display:flex; flex-direction:column; align-items:center; gap:10px;
    }
    .upload-zone:hover{ transform: translateY(-4px); border-color: rgba(0,240,255,0.18); box-shadow: 0 18px 70px rgba(0,240,255,0.03); }
    .upload-zone.dragover{ border-color: var(--neon); background: linear-gradient(180deg, rgba(0,240,255,0.03), rgba(0,240,255,0.01)); }

    .upload-cta{ font-weight:600; font-size:18px; color:var(--neon); }
    .upload-sub{ color:var(--muted); font-size:13px; margin-top:6px; }

    .file-input-overlay{ position:absolute; inset:0; opacity:0; width:100%; height:100%; cursor:pointer; }

    /* status pill */
    #status {
      margin-top:18px; display:inline-block; padding:10px 16px; border-radius:999px;
      background: linear-gradient(90deg, rgba(0,255,255,0.06), rgba(126,252,111,0.03));
      border:1px solid rgba(0,240,255,0.06); color:var(--neon);
      font-weight:600; letter-spacing:0.02em; box-shadow: 0 6px 30px rgba(0,0,0,0.6); z-index:3;
    }
    .status-ready { animation: sysPulse 2s linear infinite; }
    @keyframes sysPulse { 0%{box-shadow:0 6px 20px rgba(0,240,255,0.06)} 50%{box-shadow:0 10px 34px rgba(0,240,255,0.12)} 100%{box-shadow:0 6px 20px rgba(0,240,255,0.06)} }

    /* controls */
    #controls{ margin-top:18px; display:flex; gap:18px; flex-wrap:wrap; z-index:3; }
    .control-group{ background:var(--panel); border-radius:10px; padding:12px; border:1px solid rgba(255,255,255,0.02); min-width:220px; }
    button {
      cursor:pointer; border:1px solid rgba(255,255,255,0.04); padding:10px 14px; border-radius:8px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); color:#eafcff; font-weight:600;
      transition: transform .12s ease, box-shadow .12s ease, background .12s ease;
    }
    button:hover:not(:disabled){ transform: translateY(-3px); box-shadow:0 10px 30px rgba(0,240,255,0.04); }
    button.active, button:disabled { background: linear-gradient(180deg, rgba(0,255,255,0.08), rgba(0,255,255,0.02)); color:#042; border-color:rgba(0,255,255,0.18); }

    .preset-btn{ min-width:110px; font-size:13px; padding:8px 12px; border-radius:8px; margin:6px 6px 0 0; display:inline-block; }
    .preset-btn.active{ box-shadow: 0 6px 28px rgba(126,252,111,0.06); }

    input[type=range]{ appearance:none; background:transparent; height:6px; }
    input[type=range]::-webkit-slider-runnable-track{ height:6px; background:linear-gradient(90deg, rgba(255,255,255,0.04), rgba(0,240,255,0.06)); border-radius:4px; }
    input[type=range]::-webkit-slider-thumb{ width:14px; height:14px; border-radius:50%; background:var(--neon); box-shadow:0 6px 18px rgba(0,240,255,0.08); margin-top:-4px; }

    /* waveform/spectrogram panels */
    #waveform, #spectrogram{
      width:100%; height:220px; border-radius:8px; background:#000; margin-top:18px; border:1px solid rgba(255,255,255,0.03); box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    }
    #processed{ margin-top:18px; z-index:3; }
    #processed audio{ width:100%; border-radius:8px; }

    /* small footer */
    footer{ margin-top:28px; color:var(--muted); font-size:12px; text-align:center; z-index:3; }

    .site-footer { margin-top: 28px; color: var(--muted); font-size: 12px; text-align: center; z-index: 3; }
    .site-footer .copyright { margin-bottom: 6px; }
    .site-footer .exclusive { font-weight: 600; color: #ffdd57; letter-spacing: 0.02em; }

    /* responsive */
    @media (max-width:740px){
      .container{ padding:14px; }
      .upload-zone{ padding:30px 14px; }
      #controls{ flex-direction:column; }
      .top-actions{ flex-direction:column; gap:8px; }
    }
  </style>
</head>
<body>
  <div class="bg-noise"></div>
  <div class="scanlines"></div>

  <div class="container">
    <header class="header">
      <div class="logo" aria-hidden="true">
        <div class="logo-mark">M</div>
        <div>
          <h1>üîÆ M.A.P.S. EVP Audio Analyzer</h1>
          <div class="subtitle">Noise reduction ‚Ä¢ Voice isolation ‚Ä¢ Spectral analysis</div>
        </div>
      </div>

      <div class="top-actions" role="navigation" aria-label="top actions">
        <a href="live-visualizer.html">‚ñ∂Ô∏è Open Live Waveform & Spectrum</a>
        <a href="submit.html">üì§ Submit your EVP</a>
      </div>
    </header>

    <div id="uploadZone" class="upload-zone" tabindex="0">
      <div class="file-input-overlay">
        <input type="file" id="fileInput" accept="audio/*,.wav,.mp3,.m4a" style="width:100%;height:100%;opacity:0;">
      </div>

      <div class="upload-cta">üìÅ Drag WAV/MP3 here</div>
      <div class="upload-sub">Click or drop a file to load ‚Äî headphones recommended</div>
    </div>

    <div style="text-align:center;">
      <div id="status" class="status-ready">System Ready</div>
    </div>

    <div id="fileInfo" class="hidden"></div>

    <div id="controls" class="hidden">
      <div class="control-group">
        <button id="initBtn">üîä Load Audio</button>
        <button id="playBtn" disabled>‚ñ∂Ô∏è Play</button>
        <button id="processBtn" disabled>‚ú® Process EVP</button>
      </div>

      <div class="control-group" style="min-width:360px;">
        <label style="display:block; margin-bottom:10px;">üéõÔ∏è Presets</label>
        <div>
          <button class="preset-btn" data-preset="voice" disabled>Voice Boost</button>
          <button class="preset-btn" data-preset="clean" disabled>Clean EVP</button>
          <button class="preset-btn" data-preset="rumble" disabled>Remove Rumble</button>
          <button class="preset-btn" data-preset="whisper" disabled>Whisper Boost</button>
          <button class="preset-btn" data-preset="harsh" disabled>High Harsh Cut</button>
          <button class="preset-btn" data-preset="dark" disabled>Dark Room</button>
        </div>

        <div style="margin-top:12px;">
          <label style="display:block; font-size:13px; margin-bottom:6px;">üîá Noise Gate: <span id="noiseVal">30</span>%</label>
          <input type="range" id="noiseSlider" min="0" max="90" value="30" disabled>
          <label style="display:block; font-size:13px; margin-top:8px;">
            <input type="checkbox" id="voiceFocusToggle"> Highlight voice band (300‚Äì3000 Hz)
          </label>
        </div>
      </div>
    </div>

    <canvas id="waveform" class="hidden"></canvas>
    <canvas id="spectrogram" class="hidden"></canvas>

    <div id="processed" class="hidden">
      <h3 style="color:var(--neon-2); margin-bottom:8px;">‚ú® Processed EVP Audio</h3>
      <audio id="processedAudio" controls style="width:100%; margin-bottom: 10px; border-radius: 8px;"></audio>
      <button id="downloadBtn" class="hidden">‚¨áÔ∏è Download Processed WAV</button>
      <p style="color:var(--muted); margin-top:8px;"><em>üéß Headphones recommended.</em></p>
    </div>

    <footer class="site-footer" role="contentinfo" aria-label="site footer">
      <div class="copyright">¬© 2026 M.A.P.S. / Quantum Strangeness. All Rights Reserved.</div>
      <div class="exclusive">Code exclusive to M.A.P.S. Omaha ‚Äî Please do not scrap, copy, or reverse-engineer or we will Haunt you!</div>
    </footer>
  </div>

  <!-- Full original script (unchanged) - wires everything up -->
  <script>
        let audioContext = null;
        let source = null, analyser = null, gainNode = null, filterNode = null;
        let audioBuffer = null;
        let isPlaying = false, isInitialized = false;
        let animationId = null;
        let currentFileData = null;

        const els = {
            get uploadZone() { return document.getElementById('uploadZone'); },
            get status() { return document.getElementById('status'); },
            get fileInfo() { return document.getElementById('fileInfo'); },
            get controls() { return document.getElementById('controls'); },
            get waveform() { return document.getElementById('waveform'); },
            get spectrogram() { return document.getElementById('spectrogram'); },
            get initBtn() { return document.getElementById('initBtn'); },
            get playBtn() { return document.getElementById('playBtn'); },
            get processBtn() { return document.getElementById('processBtn'); },
            get noiseSlider() { return document.getElementById('noiseSlider'); },
            get fileInput() { return document.getElementById('fileInput'); }
        };

        function setStatus(msg, isError = false) {
            if (els.status) {
                els.status.textContent = msg;
                els.status.className = isError ? 'error glow' : 'glow';
            }
        }

        function toggleHidden(id, show) {
            const el = document.getElementById(id);
            if (el) el.classList.toggle('hidden', !show);
        }

        // File loading (unchanged)
        function loadAudioFile(file) {
            if (!file) return false;
            setStatus(`Loading ${file.name}...`);
            
            const reader = new FileReader();
            reader.onload = (e) => {
                currentFileData = e.target.result;
                if (els.fileInfo) {
                    els.fileInfo.innerHTML = `<strong>‚úÖ ${file.name}</strong><br>üìè ${(file.size/1024/1024).toFixed(1)} MB`;
                }
                toggleHidden('fileInfo', true);
                toggleHidden('controls', true);
                toggleHidden('uploadZone', false);
                setStatus('‚úÖ File loaded! Click "Load Audio" ‚Üí');
            };
            reader.onerror = () => { setStatus('‚ùå Cannot read file', true); return false; };
            reader.readAsArrayBuffer(file);
        }

        // Event handlers (unchanged)
        if (els.fileInput) els.fileInput.onchange = (e) => loadAudioFile(e.target.files[0]);
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        if (els.uploadZone) {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                els.uploadZone.addEventListener(eventName, preventDefaults, false);
            });
            ['dragenter', 'dragover'].forEach(eventName => {
                els.uploadZone.addEventListener(eventName, () => els.uploadZone.classList.add('dragover'), false);
            });
            ['dragleave', 'drop'].forEach(eventName => {
                els.uploadZone.addEventListener(eventName, () => els.uploadZone.classList.remove('dragover'), false);
            });
            els.uploadZone.addEventListener('drop', (e) => {
                preventDefaults(e);
                loadAudioFile(e.dataTransfer.files[0]);
            });
        }
        document.addEventListener('dragover', preventDefaults, false);
        document.addEventListener('drop', preventDefaults, false);

        // FIXED: Safe init (unchanged)
        if (els.initBtn) {
            els.initBtn.onclick = async () => {
                if (isInitialized || !currentFileData) return;
                try {
                    setStatus('üîÑ Initializing audio...');
                    if (!audioContext || audioContext.state === 'closed') {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 44100 });
                    }
                    await audioContext.resume();
                    audioBuffer = await audioContext.decodeAudioData(currentFileData);
                    setStatus(`‚úÖ Success: ${audioBuffer.duration.toFixed(1)}s audio`);
                    setupAudioGraph();
                    safeDrawWaveform();
                    els.initBtn.disabled = true;
                    els.initBtn.textContent = '‚úÖ Loaded!';
                    els.initBtn.classList.add('success');
                    isInitialized = true;
                    toggleHidden('waveform', true);
                    toggleHidden('spectrogram', true);
                    enableControls();
                } catch (err) {
                    setStatus(`‚ùå Decode failed: ${err.message || err.name}`, true);
                    console.error('Audio error:', err);
                }
            };
        }

        function setupAudioGraph() {
            if (!audioContext) return;
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            analyser.smoothingTimeConstant = 0.8;
            filterNode = audioContext.createBiquadFilter();
            filterNode.type = 'peaking';
            filterNode.frequency.value = 1500;
            filterNode.gain.value = 6;
            gainNode = audioContext.createGain();
            source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.loop = true;
            // CRITICAL: Proper connections
            source.connect(analyser);
            analyser.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(audioContext.destination);
        }

        function safeDrawWaveform() {
            if (!audioBuffer || !els.waveform) return;
            const canvas = els.waveform;
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            const data = new Float32Array(audioBuffer.length);
            audioBuffer.copyFromChannel(data, 0);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, rect.width, rect.height);
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const sliceCount = 1500;
            const sliceWidth = rect.width / sliceCount;
            let x = 0;
            for (let i = 0; i < sliceCount; i++) {
                const idx = Math.floor(i * audioBuffer.length / sliceCount);
                const v = Math.abs(data[idx]);
                const y = (1 - v) * rect.height / 2;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
                x += sliceWidth;
            }
            ctx.stroke();
        }

        function enableControls() {
            if (els.playBtn) els.playBtn.disabled = false;
            if (els.processBtn) els.processBtn.disabled = false;
            if (els.noiseSlider) els.noiseSlider.disabled = false;
            document.querySelectorAll('.preset-btn').forEach(btn => btn.disabled = false);
        }

        // FIXED: Play button with proper source recreation
        if (els.playBtn) {
            els.playBtn.onclick = () => {
                if (!isInitialized || !audioContext) return;
                if (audioContext.state === 'suspended') audioContext.resume();
                
                if (!isPlaying) {
                    // RECREATE SOURCE for fresh playback
                    source = audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.loop = true;
                    source.connect(analyser);
                    analyser.connect(filterNode);
                    filterNode.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    source.start(0);
                    drawLiveSpectrogram();
                    els.playBtn.textContent = '‚è∏Ô∏è Stop';
                    els.playBtn.classList.add('active');
                    isPlaying = true;
                } else {
                    source.stop();
                    if (animationId) cancelAnimationFrame(animationId);
                    els.playBtn.textContent = '‚ñ∂Ô∏è Play';
                    els.playBtn.classList.remove('active');
                    isPlaying = false;
                }
            };
        }

        function drawLiveSpectrogram() {
    if (!els.spectrogram || !analyser) return;
    const canvas = els.spectrogram;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * window.devicePixelRatio;
    canvas.height = rect.height * window.devicePixelRatio;
    ctx.scale(window.devicePixelRatio, 1);

    const dataArray = new Uint8Array(analyser.frequencyBinCount);
    const voiceFocusToggle = document.getElementById('voiceFocusToggle');

    function render() {
        if (!isPlaying) return;
        animationId = requestAnimationFrame(render);

        analyser.getByteFrequencyData(dataArray); // frequency bins 0..Nyquist

        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        ctx.fillRect(0, 0, rect.width, rect.height);

        const nyquist = audioContext.sampleRate / 2;
        const barWidth = rect.width / dataArray.length * 3;
        let x = 0;

        for (let i = 0; i < dataArray.length; i++) {
            const barHeight = dataArray[i] / 255 * rect.height;
            const freq = i / dataArray.length * nyquist;
            const inVoiceBand = freq >= 300 && freq <= 3000;

            let color;
            if (voiceFocusToggle && voiceFocusToggle.checked) {
                if (inVoiceBand) {
                    color = `hsl(120, 100%, ${barHeight / rect.height * 60 + 15}%)`; // greenish
                } else {
                    color = `hsl(200, 40%, ${barHeight / rect.height * 20 + 5}%)`;   // dim blue
                }
            } else {
                color = `hsl(${i / analyser.frequencyBinCount * 300}, 100%, ${barHeight / rect.height * 60 + 10}%)`;
            }

            ctx.fillStyle = color;
            ctx.fillRect(x, rect.height - barHeight, barWidth, barHeight);
            x += barWidth + 1;
        }
    }
    render();
}


        // FIXED: Safe preset buttons - STOP audio first, then reconnect
        document.querySelectorAll('.preset-btn').forEach(btn => {
    btn.onclick = (e) => {
        // stop audio first
        if (isPlaying) {
            source?.stop();
            if (animationId) cancelAnimationFrame(animationId);
            isPlaying = false;
            els.playBtn.textContent = '‚ñ∂Ô∏è Play';
            els.playBtn.classList.remove('active');
        }

        document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');

        if (filterNode) {
            const preset = e.target.dataset.preset;
            switch (preset) {
                case 'voice':
                    filterNode.type = 'peaking';
                    filterNode.frequency.value = 1500;
                    filterNode.Q.value = 1;
                    filterNode.gain.value = 12;
                    setStatus('üé§ Voice Boost (1‚Äì3 kHz peaking)');
                    break;
                case 'clean':
                    filterNode.type = 'lowpass';
                    filterNode.frequency.value = 5000;
                    filterNode.Q.value = 0.7;
                    filterNode.gain.value = 0;
                    setStatus('üßπ Clean EVP (cut >5 kHz hiss)');
                    break;
                case 'rumble':
                    filterNode.type = 'highpass';
                    filterNode.frequency.value = 100;
                    filterNode.Q.value = 0.7;
                    filterNode.gain.value = 0;
                    setStatus('üîà Remove Rumble (<100 Hz)');
                    break;
                case 'whisper':
                    filterNode.type = 'highpass';
                    filterNode.frequency.value = 600;
                    filterNode.Q.value = 0.7;
                    filterNode.gain.value = 0;
                    setStatus('üëª Whisper Boost (600 Hz+ focus)');
                    break;
                case 'harsh':
                    filterNode.type = 'lowpass';
                    filterNode.frequency.value = 3500;
                    filterNode.Q.value = 0.7;
                    filterNode.gain.value = 0;
                    setStatus('üßä High Harsh Cut (<3.5 kHz focus)');
                    break;
                case 'dark':
                    filterNode.type = 'lowshelf';
                    filterNode.frequency.value = 400;
                    filterNode.Q.value = 0.7;
                    filterNode.gain.value = 6;
                    setStatus('üåë Dark Room (adds body, reduces hiss)');
                    break;
            }
        }
    };
});


                // FIXED: Safe noise slider
        if (els.noiseSlider) {
            els.noiseSlider.oninput = (e) => {
                document.getElementById('noiseVal').textContent = e.target.value;
                if (gainNode) {
                    gainNode.gain.value = 1 - (parseInt(e.target.value, 10) / 100);
                }
            };
        }

        // --- Process EVP: offline render + WAV export ---
        let processedBlob = null;

        async function processEVP() {
            if (!audioBuffer || !audioContext) {
                setStatus('‚ùå No audio loaded to process', true);
                return;
            }

            try {
                setStatus('‚ú® Processing EVP (offline render)...');

                const noiseSliderEl = document.getElementById('noiseSlider');
                const noiseVal = noiseSliderEl ? parseInt(noiseSliderEl.value, 10) || 0 : 0;
                const gainFactor = 1 - noiseVal / 120;

                const offlineCtx = new OfflineAudioContext(
                    audioBuffer.numberOfChannels,
                    audioBuffer.length,
                    audioBuffer.sampleRate
                );

                const offSource = offlineCtx.createBufferSource();
                offSource.buffer = audioBuffer;

                const hp = offlineCtx.createBiquadFilter();
                hp.type = 'highpass';
                hp.frequency.value = 80;

                const bp = offlineCtx.createBiquadFilter();
                bp.type = 'bandpass';
                bp.frequency.value = 1500;
                bp.Q.value = 1;

                const lp = offlineCtx.createBiquadFilter();
                lp.type = 'lowpass';
                lp.frequency.value = 5000;

                const comp = offlineCtx.createDynamicsCompressor();
                comp.threshold.value = -30;
                comp.knee.value = 30;
                comp.ratio.value = 8;
                comp.attack.value = 0.003;
                comp.release.value = 0.25;

                const outGain = offlineCtx.createGain();
                outGain.gain.value = gainFactor;

                offSource.connect(hp);
                hp.connect(bp);
                bp.connect(lp);
                lp.connect(comp);
                comp.connect(outGain);
                outGain.connect(offlineCtx.destination);

                offSource.start(0);

                const rendered = await offlineCtx.startRendering();

                const wavBuffer = audioBufferToWav(rendered);
                processedBlob = new Blob([wavBuffer], { type: 'audio/wav' });

                const processedAudio = document.getElementById('processedAudio');
                if (processedAudio) {
                    const url = URL.createObjectURL(processedBlob);
                    processedAudio.src = url;
                    processedAudio.load();
                }

                const processedDiv = document.getElementById('processed');
                if (processedDiv) processedDiv.classList.remove('hidden');

                const downloadBtn = document.getElementById('downloadBtn');
                if (downloadBtn) downloadBtn.classList.remove('hidden');

                setStatus('‚úÖ EVP processing complete ‚Äì listen or download WAV.');
            } catch (err) {
                console.error(err);
                setStatus('‚ùå EVP processing failed: ' + (err.message || err.name), true);
            }
        }

        // Attach Process EVP button
        if (els.processBtn) {
            els.processBtn.onclick = processEVP;
        }

        // Download processed WAV
        const downloadBtnEl = document.getElementById('downloadBtn');
        if (downloadBtnEl) {
            downloadBtnEl.onclick = () => {
                if (!processedBlob) return;
                const url = URL.createObjectURL(processedBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'maps-evp-processed.wav';
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
            };
        }

        // AudioBuffer ‚Üí WAV (16‚Äëbit PCM)
        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const numFrames = buffer.length;
            const bytesPerSample = 2;
            const blockAlign = numChannels * bytesPerSample;
            const bufferLength = 44 + numFrames * blockAlign;
            const arrayBuffer = new ArrayBuffer(bufferLength);
            const view = new DataView(arrayBuffer);

            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + numFrames * blockAlign, true);
            writeString(view, 8, 'WAVE');

            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, 16, true);

            writeString(view, 36, 'data');
            view.setUint32(40, numFrames * blockAlign, true);

            const channels = [];
            for (let ch = 0; ch < numChannels; ch++) {
                channels.push(buffer.getChannelData(ch));
            }

            let offset = 44;
            for (let i = 0; i < numFrames; i++) {
                for (let ch = 0; ch < numChannels; ch++) {
                    let sample = channels[ch][i];
                    if (sample > 1) sample = 1;
                    else if (sample < -1) sample = -1;
                    view.setInt16(
                        offset,
                        sample < 0 ? sample * 0x8000 : sample * 0x7FFF,
                        true
                    );
                    offset += 2;
                }
            }
            return arrayBuffer;

            function writeString(view, offset, str) {
                for (let i = 0; i < str.length; i++) {
                    view.setUint8(offset + i, str.charCodeAt(i));
                }
            }
        }

        // keep your existing resize handler
        window.onresize = () => { if (audioBuffer) safeDrawWaveform(); };
  </script>
</body>
</html>