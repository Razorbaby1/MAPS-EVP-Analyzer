<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EVP Audio Analyzer - Quantum Strangeness</title>
    <style>
        * { box-sizing: border-box; user-select: none; }
        body { 
    font-family: -apple-system,BlinkMacSystemFont,'Segoe UI',Arial,sans-serif; 
    max-width: 1200px; margin: 0 auto; padding: 20px; 
    background:
        radial-gradient(circle at top left, rgba(255,255,255,0.06) 0, transparent 55%),
        radial-gradient(circle at bottom right, rgba(0,255,255,0.05) 0, transparent 60%),
        linear-gradient(135deg, #070707 0%, #151515 40%, #101820 100%);
    color: #eee;
}

        .header { text-align: center; margin-bottom: 40px; }
        .upload-zone { 
            position: relative; border: 4px dashed #666; border-radius: 12px;
            padding: 60px 20px; text-align: center; margin-bottom: 30px;
            background: rgba(0,0,0,0.3); transition: all 0.3s ease; cursor: pointer;
        }
        .upload-zone.dragover { border-color: #0ff; background: rgba(0,255,255,0.15); }
        .file-input-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; z-index: 10; }
        #status { padding: 15px; margin: 15px 0; background: #333; border-radius: 8px; font-weight: 500; text-align: center; }
        #fileInfo { background: linear-gradient(90deg, #222 0%, #333 100%); padding: 20px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #0ff; }
        #controls { display: flex; gap: 20px; margin-bottom: 20px; flex-wrap: wrap; }
        .control-group { display: flex; flex-direction: column; gap: 10px; }
        button { background: linear-gradient(145deg, #333, #444); color: #fff; border: none; padding: 14px 20px; border-radius: 8px; font-size: 15px; font-weight: 500; cursor: pointer; transition: all 0.2s; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
        button:hover:not(:disabled) { background: linear-gradient(145deg, #555, #666); transform: translateY(-1px); }
        button.active, button:disabled { background: linear-gradient(145deg, #0ff, #00ddff); }
        button.success { background: linear-gradient(145deg, #0a0, #0d0); }
        #waveform, #spectrogram { width: 100%; height: 220px; border: 2px solid #444; border-radius: 8px; margin-bottom: 20px; background: #000; display: block; }
        .preset-btn { background: linear-gradient(145deg, #444, #555); font-size: 13px; padding: 10px 16px; min-width: 100px; }
        .preset-btn.active { background: linear-gradient(145deg, #0a0, #0d0); }
        input[type=range] { width: 140px; height: 6px; }
        .error { background: linear-gradient(145deg, #a00, #c00) !important; box-shadow: 0 4px 12px rgba(255,0,0,0.3); }
        .hidden { display: none !important; }
        .glow { box-shadow: 0 0 20px rgba(0,255,255,0.5); }
    </style>
</head>
<body>
    <div class="header">
    <h1>üîÆ M.A.P.S. EVP Audio Analyzer</h1>
    <p style="color: #aaa; font-size: 18px;">Noise reduction ‚Ä¢ Voice isolation ‚Ä¢ Spectral analysis</p>
    <p style="margin-top:10px;">
        <a href="live-visualizer.html" style="color:#0ff; text-decoration:none; font-weight:500;">
            ‚ñ∂Ô∏è Open Live Waveform & Spectrum
        </a>
    </p>
</div>


    <div class="upload-zone" id="uploadZone">
        <div class="file-input-overlay">
            <input type="file" id="fileInput" accept="audio/*,.wav,.mp3,.m4a" style="width:100%;height:100%;opacity:0;">
        </div>
        <p style="margin: 0; font-size: 18px;">
            <strong>üìÅ Drag WAV/MP3 here</strong><br>
            <small style="color:#aaa;">Click anywhere to browse</small>
        </p>
    </div>

    <div id="status">Ready to analyze EVP recordings</div>
    <div id="fileInfo" class="hidden"></div>

    <div id="controls" class="hidden">
        <div class="control-group">
            <button id="initBtn">üîä Load Audio</button>
            <button id="playBtn" disabled>‚ñ∂Ô∏è Play</button>
            <button id="processBtn" disabled>‚ú® Process EVP</button>
        </div>
        <div class="control-group">
            <label>üéõÔ∏è Presets:</label>
            <button class="preset-btn" data-preset="voice" disabled>Voice Boost</button>
            <button class="preset-btn" data-preset="clean" disabled>Clean EVP</button>
            <button class="preset-btn" data-preset="rumble" disabled>Remove Rumble</button>
            <button class="preset-btn" data-preset="whisper" disabled>Whisper Boost</button>
            <button class="preset-btn" data-preset="harsh" disabled>High Harsh Cut</button>
            <button class="preset-btn" data-preset="dark" disabled>Dark Room</button>
        </div>
            <div class="control-group">
        <label>üîá Noise Gate: <span id="noiseVal">30</span>%</label>
        <input type="range" id="noiseSlider" min="0" max="90" value="30" disabled>
        <label style="margin-top:6px; font-size: 13px;">
            <input type="checkbox" id="voiceFocusToggle"> Highlight voice band (300‚Äì3000 Hz)
        </label>
    </div>
</div>  <!-- end of #controls -->



<div id="processed" class="hidden">
    <h3>‚ú® Processed EVP Audio</h3>
    <audio id="processedAudio" controls style="width:100%; margin-bottom: 10px; border-radius: 8px;"></audio>
    <button id="downloadBtn" class="hidden">‚¨áÔ∏è Download Processed WAV</button>
    <p><em>üéß Headphones recommended.</em></p>
</div>





    <script>
        let audioContext = null;
        let source = null, analyser = null, gainNode = null, filterNode = null;
        let audioBuffer = null;
        let isPlaying = false, isInitialized = false;
        let animationId = null;
        let currentFileData = null;

        const els = {
            get uploadZone() { return document.getElementById('uploadZone'); },
            get status() { return document.getElementById('status'); },
            get fileInfo() { return document.getElementById('fileInfo'); },
            get controls() { return document.getElementById('controls'); },
            get waveform() { return document.getElementById('waveform'); },
            get spectrogram() { return document.getElementById('spectrogram'); },
            get initBtn() { return document.getElementById('initBtn'); },
            get playBtn() { return document.getElementById('playBtn'); },
            get processBtn() { return document.getElementById('processBtn'); },
            get noiseSlider() { return document.getElementById('noiseSlider'); },
            get fileInput() { return document.getElementById('fileInput'); }
        };

        function setStatus(msg, isError = false) {
            if (els.status) {
                els.status.textContent = msg;
                els.status.className = isError ? 'error glow' : 'glow';
            }
        }

        function toggleHidden(id, show) {
            const el = document.getElementById(id);
            if (el) el.classList.toggle('hidden', !show);
        }

        // File loading (unchanged)
        function loadAudioFile(file) {
            if (!file) return false;
            setStatus(`Loading ${file.name}...`);
            
            const reader = new FileReader();
            reader.onload = (e) => {
                currentFileData = e.target.result;
                if (els.fileInfo) {
                    els.fileInfo.innerHTML = `<strong>‚úÖ ${file.name}</strong><br>üìè ${(file.size/1024/1024).toFixed(1)} MB`;
                }
                toggleHidden('fileInfo', true);
                toggleHidden('controls', true);
                toggleHidden('uploadZone', false);
                setStatus('‚úÖ File loaded! Click "Load Audio" ‚Üí');
            };
            reader.onerror = () => { setStatus('‚ùå Cannot read file', true); return false; };
            reader.readAsArrayBuffer(file);
        }

        // Event handlers (unchanged)
        if (els.fileInput) els.fileInput.onchange = (e) => loadAudioFile(e.target.files[0]);
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        if (els.uploadZone) {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                els.uploadZone.addEventListener(eventName, preventDefaults, false);
            });
            ['dragenter', 'dragover'].forEach(eventName => {
                els.uploadZone.addEventListener(eventName, () => els.uploadZone.classList.add('dragover'), false);
            });
            ['dragleave', 'drop'].forEach(eventName => {
                els.uploadZone.addEventListener(eventName, () => els.uploadZone.classList.remove('dragover'), false);
            });
            els.uploadZone.addEventListener('drop', (e) => {
                preventDefaults(e);
                loadAudioFile(e.dataTransfer.files[0]);
            });
        }
        document.addEventListener('dragover', preventDefaults, false);
        document.addEventListener('drop', preventDefaults, false);

        // FIXED: Safe init (unchanged)
        if (els.initBtn) {
            els.initBtn.onclick = async () => {
                if (isInitialized || !currentFileData) return;
                try {
                    setStatus('üîÑ Initializing audio...');
                    if (!audioContext || audioContext.state === 'closed') {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 44100 });
                    }
                    await audioContext.resume();
                    audioBuffer = await audioContext.decodeAudioData(currentFileData);
                    setStatus(`‚úÖ Success: ${audioBuffer.duration.toFixed(1)}s audio`);
                    setupAudioGraph();
                    safeDrawWaveform();
                    els.initBtn.disabled = true;
                    els.initBtn.textContent = '‚úÖ Loaded!';
                    els.initBtn.classList.add('success');
                    isInitialized = true;
                    toggleHidden('waveform', true);
                    toggleHidden('spectrogram', true);
                    enableControls();
                } catch (err) {
                    setStatus(`‚ùå Decode failed: ${err.message || err.name}`, true);
                    console.error('Audio error:', err);
                }
            };
        }

        function setupAudioGraph() {
            if (!audioContext) return;
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            analyser.smoothingTimeConstant = 0.8;
            filterNode = audioContext.createBiquadFilter();
            filterNode.type = 'peaking';
            filterNode.frequency.value = 1500;
            filterNode.gain.value = 6;
            gainNode = audioContext.createGain();
            source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.loop = true;
            // CRITICAL: Proper connections
            source.connect(analyser);
            analyser.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(audioContext.destination);
        }

        function safeDrawWaveform() {
            if (!audioBuffer || !els.waveform) return;
            const canvas = els.waveform;
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            const data = new Float32Array(audioBuffer.length);
            audioBuffer.copyFromChannel(data, 0);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, rect.width, rect.height);
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const sliceCount = 1500;
            const sliceWidth = rect.width / sliceCount;
            let x = 0;
            for (let i = 0; i < sliceCount; i++) {
                const idx = Math.floor(i * audioBuffer.length / sliceCount);
                const v = Math.abs(data[idx]);
                const y = (1 - v) * rect.height / 2;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
                x += sliceWidth;
            }
            ctx.stroke();
        }

        function enableControls() {
            if (els.playBtn) els.playBtn.disabled = false;
            if (els.processBtn) els.processBtn.disabled = false;
            if (els.noiseSlider) els.noiseSlider.disabled = false;
            document.querySelectorAll('.preset-btn').forEach(btn => btn.disabled = false);
        }

        // FIXED: Play button with proper source recreation
        if (els.playBtn) {
            els.playBtn.onclick = () => {
                if (!isInitialized || !audioContext) return;
                if (audioContext.state === 'suspended') audioContext.resume();
                
                if (!isPlaying) {
                    // RECREATE SOURCE for fresh playback
                    source = audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.loop = true;
                    source.connect(analyser);
                    analyser.connect(filterNode);
                    filterNode.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    source.start(0);
                    drawLiveSpectrogram();
                    els.playBtn.textContent = '‚è∏Ô∏è Stop';
                    els.playBtn.classList.add('active');
                    isPlaying = true;
                } else {
                    source.stop();
                    if (animationId) cancelAnimationFrame(animationId);
                    els.playBtn.textContent = '‚ñ∂Ô∏è Play';
                    els.playBtn.classList.remove('active');
                    isPlaying = false;
                }
            };
        }

        function drawLiveSpectrogram() {
    if (!els.spectrogram || !analyser) return;
    const canvas = els.spectrogram;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * window.devicePixelRatio;
    canvas.height = rect.height * window.devicePixelRatio;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

    const dataArray = new Uint8Array(analyser.frequencyBinCount);
    const voiceFocusToggle = document.getElementById('voiceFocusToggle');

    function render() {
        if (!isPlaying) return;
        animationId = requestAnimationFrame(render);

        analyser.getByteFrequencyData(dataArray); // frequency bins 0..Nyquist[web:179][web:176]

        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        ctx.fillRect(0, 0, rect.width, rect.height);

        const nyquist = audioContext.sampleRate / 2;
        const barWidth = rect.width / dataArray.length * 3;
        let x = 0;

        for (let i = 0; i < dataArray.length; i++) {
            const barHeight = dataArray[i] / 255 * rect.height;
            const freq = i / dataArray.length * nyquist;
            const inVoiceBand = freq >= 300 && freq <= 3000;

            let color;
            if (voiceFocusToggle && voiceFocusToggle.checked) {
                if (inVoiceBand) {
                    color = `hsl(120, 100%, ${barHeight / rect.height * 60 + 15}%)`; // greenish
                } else {
                    color = `hsl(200, 40%, ${barHeight / rect.height * 20 + 5}%)`;   // dim blue
                }
            } else {
                color = `hsl(${i / analyser.frequencyBinCount * 300}, 100%, ${barHeight / rect.height * 60 + 10}%)`;
            }

            ctx.fillStyle = color;
            ctx.fillRect(x, rect.height - barHeight, barWidth, barHeight);
            x += barWidth + 1;
        }
    }
    render();
}


        // FIXED: Safe preset buttons - STOP audio first, then reconnect
        document.querySelectorAll('.preset-btn').forEach(btn => {
    btn.onclick = (e) => {
        // stop audio first
        if (isPlaying) {
            source?.stop();
            if (animationId) cancelAnimationFrame(animationId);
            isPlaying = false;
            els.playBtn.textContent = '‚ñ∂Ô∏è Play';
            els.playBtn.classList.remove('active');
        }

        document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');

        if (filterNode) {
            const preset = e.target.dataset.preset;
            switch (preset) {
                case 'voice':
                    filterNode.type = 'peaking';
                    filterNode.frequency.value = 1500;
                    filterNode.Q.value = 1;
                    filterNode.gain.value = 12;
                    setStatus('üé§ Voice Boost (1‚Äì3 kHz peaking)');
                    break;
                case 'clean':
                    filterNode.type = 'lowpass';
                    filterNode.frequency.value = 5000;
                    filterNode.Q.value = 0.7;
                    filterNode.gain.value = 0;
                    setStatus('üßπ Clean EVP (cut >5 kHz hiss)');
                    break;
                case 'rumble':
                    filterNode.type = 'highpass';
                    filterNode.frequency.value = 100;
                    filterNode.Q.value = 0.7;
                    filterNode.gain.value = 0;
                    setStatus('üîà Remove Rumble (<100 Hz)');
                    break;
                case 'whisper':
                    filterNode.type = 'highpass';
                    filterNode.frequency.value = 600;
                    filterNode.Q.value = 0.7;
                    filterNode.gain.value = 0;
                    setStatus('üëª Whisper Boost (600 Hz+ focus)');
                    break;
                case 'harsh':
                    filterNode.type = 'lowpass';
                    filterNode.frequency.value = 3500;
                    filterNode.Q.value = 0.7;
                    filterNode.gain.value = 0;
                    setStatus('üßä High Harsh Cut (<3.5 kHz focus)');
                    break;
                case 'dark':
                    filterNode.type = 'lowshelf';
                    filterNode.frequency.value = 400;
                    filterNode.Q.value = 0.7;
                    filterNode.gain.value = 6;
                    setStatus('üåë Dark Room (adds body, reduces hiss)');
                    break;
            }
        }
    };
});


                // FIXED: Safe noise slider
        if (els.noiseSlider) {
            els.noiseSlider.oninput = (e) => {
                document.getElementById('noiseVal').textContent = e.target.value;
                if (gainNode) {
                    gainNode.gain.value = 1 - (parseInt(e.target.value, 10) / 100);
                }
            };
        }

        // --- Process EVP: offline render + WAV export ---
        let processedBlob = null;

        async function processEVP() {
            if (!audioBuffer || !audioContext) {
                setStatus('‚ùå No audio loaded to process', true);
                return;
            }

            try {
                setStatus('‚ú® Processing EVP (offline render)...');

                const noiseSliderEl = document.getElementById('noiseSlider');
                const noiseVal = noiseSliderEl ? parseInt(noiseSliderEl.value, 10) || 0 : 0;
                const gainFactor = 1 - noiseVal / 120;

                const offlineCtx = new OfflineAudioContext(
                    audioBuffer.numberOfChannels,
                    audioBuffer.length,
                    audioBuffer.sampleRate
                );

                const offSource = offlineCtx.createBufferSource();
                offSource.buffer = audioBuffer;

                const hp = offlineCtx.createBiquadFilter();
                hp.type = 'highpass';
                hp.frequency.value = 80;

                const bp = offlineCtx.createBiquadFilter();
                bp.type = 'bandpass';
                bp.frequency.value = 1500;
                bp.Q.value = 1;

                const lp = offlineCtx.createBiquadFilter();
                lp.type = 'lowpass';
                lp.frequency.value = 5000;

                const comp = offlineCtx.createDynamicsCompressor();
                comp.threshold.value = -30;
                comp.knee.value = 30;
                comp.ratio.value = 8;
                comp.attack.value = 0.003;
                comp.release.value = 0.25;

                const outGain = offlineCtx.createGain();
                outGain.gain.value = gainFactor;

                offSource.connect(hp);
                hp.connect(bp);
                bp.connect(lp);
                lp.connect(comp);
                comp.connect(outGain);
                outGain.connect(offlineCtx.destination);

                offSource.start(0);

                const rendered = await offlineCtx.startRendering();

                const wavBuffer = audioBufferToWav(rendered);
                processedBlob = new Blob([wavBuffer], { type: 'audio/wav' });

                const processedAudio = document.getElementById('processedAudio');
                if (processedAudio) {
                    const url = URL.createObjectURL(processedBlob);
                    processedAudio.src = url;
                    processedAudio.load();
                }

                const processedDiv = document.getElementById('processed');
                if (processedDiv) processedDiv.classList.remove('hidden');

                const downloadBtn = document.getElementById('downloadBtn');
                if (downloadBtn) downloadBtn.classList.remove('hidden');

                setStatus('‚úÖ EVP processing complete ‚Äì listen or download WAV.');
            } catch (err) {
                console.error(err);
                setStatus('‚ùå EVP processing failed: ' + (err.message || err.name), true);
            }
        }

        // Attach Process EVP button
        if (els.processBtn) {
            els.processBtn.onclick = processEVP;
        }

        // Download processed WAV
        const downloadBtnEl = document.getElementById('downloadBtn');
        if (downloadBtnEl) {
            downloadBtnEl.onclick = () => {
                if (!processedBlob) return;
                const url = URL.createObjectURL(processedBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'maps-evp-processed.wav';
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
            };
        }

        // AudioBuffer ‚Üí WAV (16‚Äëbit PCM)
        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const numFrames = buffer.length;
            const bytesPerSample = 2;
            const blockAlign = numChannels * bytesPerSample;
            const bufferLength = 44 + numFrames * blockAlign;
            const arrayBuffer = new ArrayBuffer(bufferLength);
            const view = new DataView(arrayBuffer);

            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + numFrames * blockAlign, true);
            writeString(view, 8, 'WAVE');

            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, 16, true);

            writeString(view, 36, 'data');
            view.setUint32(40, numFrames * blockAlign, true);

            const channels = [];
            for (let ch = 0; ch < numChannels; ch++) {
                channels.push(buffer.getChannelData(ch));
            }

            let offset = 44;
            for (let i = 0; i < numFrames; i++) {
                for (let ch = 0; ch < numChannels; ch++) {
                    let sample = channels[ch][i];
                    if (sample > 1) sample = 1;
                    else if (sample < -1) sample = -1;
                    view.setInt16(
                        offset,
                        sample < 0 ? sample * 0x8000 : sample * 0x7FFF,
                        true
                    );
                    offset += 2;
                }
            }
            return arrayBuffer;

            function writeString(view, offset, str) {
                for (let i = 0; i < str.length; i++) {
                    view.setUint8(offset + i, str.charCodeAt(i));
                }
            }
        }

        // keep your existing resize handler
        window.onresize = () => { if (audioBuffer) safeDrawWaveform(); };
    </script>
</body>
</html>
